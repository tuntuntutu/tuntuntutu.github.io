## 正则表达式（regular expression）

> 正则表达式是用一个“字符串”来描述一个特征，然后去验证另一个“字符串”是否符合这个特征，比如 表达式“ab+” 描述的特征是“一个 'a' 和 任意个 'b' ”，那么 'ab', 'abb', 'abbbbbbbbbb' 都符合这个特征。

- 验证字符串是否符合指定特征，比如验证是否是合法的邮件地址
- 用来查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便
- 用来替换，比普通的替换更强大

### 普通字符
- 字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是普通字符
- 表达式"c",在匹配字符串"abcde"时，匹配结果是：成功，匹配到的内容是："c"，匹配到的位置是：开始于2，结束于3
-  表达式 "bcd"，在匹配字符串 "abcde" 时，匹配结果是：成功；匹配到的内容是："bcd"；匹配到的位置是：开始于1，结束于4。

### 简单转义字符
被用于正则表达式的字符，需要进行转义才能匹配到字符原意如
$()*+.[]?\^{},|

- ^ 匹配输入字符串的开始位置。要匹配 "^" 字符本身，请使用 "\^"
- $ 匹配输入字符串的结尾位置。要匹配 "$" 字符本身，请使用 "\$"
- ( ) 标记一个子表达式的开始和结束位置。要匹配小括号，请使用 "\(" 和 "\)"
- [] 用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 "\[" 和 "\]"
- { } 修饰匹配次数的符号。要匹配大括号，请使用 "\{" 和 "\}"
- . 匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 "\."
- \? 修饰匹配次数为 0 次或 1 次。要匹配 "?" 字符本身，请使用 "\?"
- \+ 修饰匹配次数为至少 1 次。要匹配 "+" 字符本身，请使用 "\+"
- \* 修饰匹配次数为 0 次或任意次。要匹配 "*" 字符本身，请使用 "\*"
- | 左右两边表达式之间 "或" 关系。匹配 "|" 本身，请使用 "\|"


### 匹配单多字符
定义的字母或字符，如要从url里匹配参数的位置，就多字符的形式如，要取url中的参数id参数的值,
```
var str = 'http://m.kaola.com/h5/activity.html?id=23423'
var reg = /id=([^&]+)&?/;
str.match(reg)
```
### 通配符匹配
- \d 匹配任意数字[0-9]
- \w 匹配字母数字下划线
- \s 包括空格、制表符、换页符等空白字符的其中任意一个，不包括回车符
- .  匹配除换行符以外的任意字符
- \S 匹配所有非空白字符（"\s" 可匹配各个空白字符）
- \D 匹配所有的非数字字符
- \W 匹配所有的字母、数字、下划线以外的字符
- \B 匹配非单词边界，即左右两边都是 "\w" 范围或者左右两边都不是 "\w" 范围时的字符缝隙

- 表达式 "\d\d"，在匹配 "abc123"  时，匹配到的内容是："12"；匹配到的位置是：开始于3，结束于5。
- 表达式 "a.\d"，在匹配 "aaa100"时，匹配的结果是：成功；匹配到的内容是："aa1"；匹配到的位置是：开始于1，结束于4。


### 字定义多种字符匹配
- `[ab5@]` 匹配 "a" 或 "b" 或 "5" 或 "@"
- `[^abc]` 匹配 "a","b","c" 之外的任意一个字符
- [f-k]  匹配 "f"~"k" 之间的任意一个字母
- `[^A-F0-3]` 匹配 "A" ~ "F","0"~"3" 之外的任意一个字符
-  "[bcd][bcd]" 匹配"abc123"时，匹配的结果是：成功；匹配到的内容是："bc"；匹配到的位置是：开始于1，结束于3。
- `[^abc]` 匹配 "abc123" 时，匹配的结果是：成功；匹配到的内容是："1"；匹配到的位置是：开始于3，结束于4。

### 修饰匹配次数的特殊符号
- "次数修饰"放在"被修饰的表达式"后边,比如："[bcd][bcd]" 可以写成 "[bcd]{2}"
- {n}  表达式重复n次 "\w{2}" 相当于 "\w\w"；"a{5}" 相当于 "aaaaa"
- {m,n} 表达式至少重复m次，最多重复n次，比如："ba{1,3}"可以匹配 "ba"或"baa"或"baaa"
- {m,} 表达式至少重复m次，比如： "\w\d{2,}"可以匹配 "a12","_456","M12344"...
- \?  匹配表达式0次或者1次，相当于 {0,1}，比如： "a[cd]?"可以匹配 "a","ac","ad"
- \+ 表达式至少出现1次，相当于 {1,}，比如： "a+b"可以匹配 "ab","aab","aaab"...
- \* 表达式不出现或出现任意次，相当于 {0,}，比如： "\^*b"可以匹配 "b","^^^b"

### 边界字符
- ^ 与字符串开始的地方匹配，不匹配任何字符
- $ 与字符串结束的地方匹配，不匹配任何字符
- \b 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符

> 进一步说明："\b" 与 "^" 和 "$" 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 "\w" 范围，另一边是 非"\w" 的范围

- 表达式 "^aaa" 在匹配 "xxx aaa xxx" 时，匹配结果是：失败。因为 "^" 要求与字符串开始的地方匹配，因此，只有当 "aaa" 位于字符串的开头的时候，"^aaa" 才能匹配， 比如："aaa xxx xxx"。
- 表达式 "aaa$" 在匹配 "xxx aaa xxx" 时，匹配结果是：失败。因为 "$" 要求与字符串结束的地方匹配，因此，只有当 "aaa" 位于字符串的结尾的时候，"aaa$" 才能匹配， 比如："xxx xxx aaa"。
- 表达式 ".\b." 在匹配 "@@@abc" 时，匹配结果是：成功；匹配到的内容是："@a"；匹配到的位置是：开始于2，结束于4


- ()在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰
- ()取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到


- 表达式 "Tom|Jack" 在匹配字符串 "I'm Tom, he is Jack" 时，匹配结果是：成功；匹配到的内容是："Tom"；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是："Jack"；匹配到的位置时：开始于15，结束于19。

- 表达式 "(go\s*)+" 在匹配 "Let's go go go!" 时，匹配结果是：成功；匹配到内容是："go go go"；匹配到的位置是：开始于6，结束于14。
- 表达式 "￥(\d+\.?\d*)" 在匹配 "＄10.9,￥20.5" 时，匹配的结果是：成功；匹配到的内容是："￥20.5"；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是："20.5"。


### 匹配次数中的贪婪与非贪婪
- 
```
(d)(\w+) dxxxdxxxd
```
中 "\w+" 将匹配第一个 "d" 之后的所有字符 "xxxdxxxd"

- 
```
(d)(\w+)(d) dxxxdxxxd
```
中 "\w+" 将匹配第一个 "d" 和最后一个 "d" 之间的所有字符 "xxxdxxx"。虽然 "\w+" 也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功; "\w+" 可以 "让出" 它本来能够匹配的最后一个 "d","\w+" 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 "d"，但那也是为了让整个表达式能够匹配成功。同理，带 "*" 和 "{m,n}" 的表达式都是尽可能地多匹配，带 "?" 的表达式在可匹配可不匹配的时候，也是尽可能的 "要匹配"。这 种匹配原则就叫作 "贪婪" 模式 

### 非贪婪模式
在修饰匹配次数的特殊符号后再加上一个 "?" 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 "不匹配"。这种匹配原则叫作 "非贪婪" 模式，也叫作 "勉强" 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功

- (d)(\w+?)  dxxxdxxxd中 "\w+?" 将尽可能少的匹配第一个 "d" 之后的字符，结果是："\w+?" 只匹配了一个 "x"
-  (d)(\w+?)(d) dxxxdxxxd中为了让整个表达式匹配成功，"\w+?" 不得不匹配 "xxx" 才可以让后边的 "d" 匹配，从而使整个表达式匹配成功。因此，结果是："\w+?" 匹配 "xxx"
- 表达式 `<td>(.*)</td>` 与字符串 `<td><p>aa</p></td> <td><p>bb</p></td>` 匹配时，匹配的结果是：成功；匹配到的内容是 `<td><p>aa</p></td> <td><p>bb</p></td>` 整个字符串， 表达式中的 `</td>` 将与字符串中最后一个 `</td>` 匹配。 
- 表达式 `<td>(.*?)</td>` 匹配举例1中同样的字符串时，将只得到 `<td><p>aa</p></td>`， 再次匹配下一个时，可以得到第二个 `<td><p>bb</p></td>`。


### 反向引用 \1, \2 ...
表达式在匹配时，表达式引擎会将小括号 "( )" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 "<td>(.*?)</td>"

- 表达式 "('|")(.*?)(\1)" 在匹配 " 'Hello', "World" " 时，匹配结果是：成功；匹配到的内容是：" 'Hello' "。再次匹配下一个时，可以匹配到 " "World" "。
- 表达式 "(\w)\1{4,}" 在匹配 "aa bbbb abcdefg ccccc 111121111 999999999" 时，匹配结果是：成功；匹配到的内容是 "ccccc"。再次匹配下一个时，将得到 999999999。这个表达式要求 "\w" 范围的字符至少重复5次，点击测试 注意与 "\w{5,}" 之间的区别。
- 表达式 

```
"<(\w+)\s*(\w+(=('|").*?\4)?\s*)*>.*?</\1>"
```
匹配
```
"<td id='td1' style="bgcolor:white"></td>"
```
 时，匹配结果是成功。如果 "<td>" 与 "</td>" 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。

### test , exec, match
- test

test是正则表达式的方法，结果是否匹配正则表达式，一般是对指定的字符串进行测试，是否包含正则特征
```
var reg =/13\d{9}/;
var str = 'ad13588231066';
reg.test(str)
```
- exec

exec 是正则表达式的方法，如果有g对exec本身的影响是,当一个具有g的正则表达式调用exec()时,他将该对象的lastIndex设置到紧接这匹配子串的字符位置.当第二次调用exec时将从lastIndex所指示的字符位置开始检索.利用这个特点可以反复调用exec遍历所有匹配，exec如果有分组内容，返回的数组里，0是匹配的字符串，后面的1，2，3是分组的内容
- match

match方法属于String正则表达方法. 有g全局标志,那么返回的数组保存的是,所有匹配的内容，match不能提取分组里的内容

### 实例

-  一个正则表达式，只含有汉字、数字、字母、下划线不能以下划线开头和结尾：

```

^(?!_)(?!.*?_$)[a-zA-Z0-9_\u4e00-\u9fa5]+$ 
其中：
^ 与字符串开始的地方匹配
(?!_)　　不能以_开头
(?!.*?_$)　　不能以_结尾
[a-zA-Z0-9_\u4e00-\u9fa5]+　　至少一个汉字、数字、字母、下划线
$　　与字符串结束的地方匹配

```
  
- 只含有汉字、数字、字母、下划线，下划线位置不限：

```
 ^[a-zA-Z0-9_\u4e00-\u9fa5]+$
```
  
- 由数字、26个英文字母或者下划线组成的字符串

```
^\w+$
```
  
- 2~4个汉字

```
 @"^[\u4E00-\u9FA5]{2,4}$"
```


-  邮箱

```
^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$
```

  
- 匹配汉字、字母、下划线

```
[^\u4E00-\u9FA50-9a-zA-Z_]

```




### 传送门
1.  [正则表达式](http://www.regexlab.com/zh/regref.htm)
2.  [正则转流程图](https://jex.im/regulex/)
3.  [正则表达式在线测试](http://tool.chinaz.com/regex/)